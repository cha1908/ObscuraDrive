# Obscura Drive

Encrypted file registry that keeps IPFS references confidential with Zama FHEVM, an ephemeral EVM address, and a Sepolia-first React + Vite dapp. The contract anchors only encrypted metadata: file name, encrypted CID, and a Zama-encrypted handle for the random address used as the XOR key. Users decrypt on demand through the Zama relayer without leaking the key on-chain.

## What it solves
- Makes on-chain file pointers private: the IPFS-like hash is never stored in cleartext.
- Avoids key reuse by minting a fresh address A per file and using it as the encryption seed.
- Keeps ACL explicit: the contract sets FHE permissions at upload and lets the owner delegate decryption later.
- Separates reads/writes correctly (viem for reads, ethers for writes) to prevent accidental signer leaks.

## Key advantages
- **End-to-end confidentiality**: CID is XOR-encrypted locally; the XOR key (address A) is FHE-encrypted on-chain.
- **Deterministic, replayable flow**: encryption is deterministic per A, so decrypting the stored key always recovers the same CID.
- **Ready for real IPFS**: a pseudo uploader is in place; swapping to a real pinning flow is isolated to `home/src/utils/ipfs.ts`.
- **Network hygiene**: frontend is hardwired to Sepolia, no localhost/localstorage dependency, and avoids env-based config.
- **Upgradeable UX hooks**: Zama relayer wiring is encapsulated in `useZamaInstance`, and contract writes are gated on a populated `CONTRACT_ADDRESS`.

## System flow
1. User picks a local file (frontend never sends file contents to the chain).
2. The app pseudo-uploads to IPFS to produce a base58 hash (stub in `pseudoUploadToIpfs`).
3. A random address A is generated; the IPFS hash is XOR-encrypted with A to produce `encryptedCid`.
4. A is encrypted with Zama (Relayer SDK) to produce an `eaddress` handle and proof.
5. The contract `uploadFile` stores {fileName, encryptedCid, encryptedKey, createdAt} mapped to the uploader.
6. Anyone with ACL rights can call user-decrypt via the relayer to recover A, then decrypt the CID client-side.
7. Optional: uploader can grant another address permission with `authorizeDecrypt`.

## Tech stack
- Smart contracts: Hardhat + hardhat-deploy, Solidity 0.8.27, FHEVM solidity libs, TypeChain, ethers v6.
- Encryption: Zama Relayer SDK (Sepolia config), XOR-based CID obfuscation keyed by ephemeral address A.
- Frontend: React + Vite, RainbowKit/wagmi + WalletConnect, viem for reads, ethers for writes, vanilla CSS (no Tailwind).
- Tooling: hardhat-gas-reporter, solidity-coverage, npm (no pnpm/yarn), Vitest is unused.

## Repository layout
- `contracts/ObscuraDrive.sol` — core FHE-enabled vault contract.
- `deploy/deploy.ts` — hardhat-deploy script for local and Sepolia.
- `tasks/drive.ts` — CLI helpers to upload and decrypt sample entries.
- `test/ObscuraDrive.ts` — mock FHEVM tests on Hardhat.
- `test/ObscuraDriveSepolia.ts` — live Sepolia FHEVM test (requires deployed contract).
- `home/` — production frontend (React + Vite); avoid editing `home/src/hooks/*`.
- `deployments/` — autogenerated artifacts and ABIs (copy ABI/address for the frontend).
- `docs/` — Zama FHEVM and relayer reference notes.

## Contract behavior
- `uploadFile(string fileName, string encryptedCid, externalEaddress encryptedKey, bytes inputProof)`  
  Validates inputs, converts the external encrypted key, sets ACL (`allow` uploader + `allowThis` contract), emits `FileStored`.
- `authorizeDecrypt(address owner, uint256 fileId, address beneficiary)`  
  Only the owner can grant future decryption rights for a stored key; emits `AccessGranted`.
- `getFile`, `getFiles`, `getFileCount`  
  Pure views returning stored metadata without relying on `msg.sender`.

Notes:
- View functions never use `msg.sender` for access control.
- ACL is applied once during upload and can be extended via `authorizeDecrypt`.
- The contract never stores raw file bytes—only encrypted references and timestamps.

## Frontend (home/)
- Reads via viem (`useReadContract`), writes via ethers `Contract`.
- Zama relayer setup is encapsulated in `useZamaInstance` (Sepolia config, no env vars).
- Contract address/ABI live in `home/src/config/contracts.ts` (ABI must match `deployments/sepolia/ObscuraDrive.json`; update `CONTRACT_ADDRESS` after deployment).
- Flow components:
  - `FileUpload` — pseudo IPFS hash generation, XOR encryption with A, Zama encryption, and `uploadFile` submission.
  - `FileList` — fetches `getFiles(owner)`, user-decrypts the stored key, and derives the original CID client-side.
- Styling uses CSS modules in `home/src/styles` (no Tailwind, no JSON config).

## Prerequisites
- Node 18+ and npm.
- For Sepolia work: `.env` with `INFURA_API_KEY`, `PRIVATE_KEY` (hex, no mnemonic), optional `ETHERSCAN_API_KEY`.  
  Example `.env` (do not commit):
  ```
  INFURA_API_KEY=xxxx
  PRIVATE_KEY=0xabcdef...
  ETHERSCAN_API_KEY=yyyy
  ```

## Local development
1. Install deps: `npm install`
2. Compile contracts: `npm run compile`
3. Run tests on mock FHEVM: `npm test`
4. Optional gas report: `REPORT_GAS=1 npm test`

## Deployment
- Local node: `npx hardhat deploy` (uses hardhat network).
- Sepolia: `npx hardhat deploy --network sepolia` (requires `INFURA_API_KEY` + `PRIVATE_KEY`, no mnemonic).  
  - Deployment artifacts land in `deployments/sepolia/ObscuraDrive.json`.
  - Copy the deployed address into `home/src/config/contracts.ts` (`CONTRACT_ADDRESS`), and keep the ABI synced from the same file.
- Verification (optional): `npx hardhat verify --network sepolia <address>`

## Hardhat tasks
- `npx hardhat drive:address` — print the latest deployment address.
- `npx hardhat drive:upload --name "plan.pdf" --cid QmHashHere` — demo upload with ephemeral A and Zama encryption.
- `npx hardhat drive:first --owner <address?>` — decrypt the first stored entry for an owner.

## Frontend usage
1. Set `CONTRACT_ADDRESS` in `home/src/config/contracts.ts` to the Sepolia deployment.
2. `cd home && npm install`
3. `npm run dev` to serve locally (connect wallet to Sepolia); `npm run build` for a production check.
4. Workflow in-app: choose file → generate pseudo IPFS hash → store encrypted record → fetch/decrypt from the list.

## Limitations and current assumptions
- IPFS is mocked: hashes are deterministic placeholders until a real pinning service is wired in.
- Encryption scheme is XOR + address-derived key for demonstrability; swap with stronger client-side encryption as needed.
- Frontend is Sepolia-only and does not fall back to localhost networks.

## Future roadmap
- Replace pseudo IPFS with actual uploads/pinning plus retrieval links.
- Rich ACL management: share records with multiple beneficiaries and revoke access.
- Batch uploads and pagination for large file sets.
- UI polish: upload progress, toast notifications, and copy-to-clipboard for decrypted data.
- Multi-network readiness once FHEVM support expands beyond Sepolia.
- Continuous security hardening: add fuzz tests and formal checks for ACL invariants.
